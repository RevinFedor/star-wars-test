# Star Wars Characters App

═══════════════════════════════════════════════════════════════════════
# ОБЗОР ПРОЕКТА
═══════════════════════════════════════════════════════════════════════

**Приложение для просмотра и редактирования персонажей Star Wars:** загружает данные из SWAPI API, позволяет редактировать любые поля персонажа с сохранением в `localStorage`, поиск с debounce *300ms*, пагинация с URL state. Изменения отображаются только локально и не отправляются на сервер, при этом API данные мержатся с локальными правками через приоритет `localStorage`.

**Flip-анимация карточек:** при наведении карточка переворачивается с фронтальной стороны (изображение + имя) на обратную (детали персонажа) через `framer-motion` с `rotateY(180deg)` и `backfaceVisibility: hidden`. Вертикальные изображения с `aspect-ratio: 3/4` загружаются из `akabab.github.io/starwars-api`, при отсутствии показывается плейсхолдер.

**Badge "Edited" для измененных персонажей:** если персонаж имеет локальные правки, на карточке и детальной странице появляется *Edited* badge с иконкой `Edit3` из `lucide-react`. В детальной странице рядом с каждым измененным полем показывается кнопка *Undo* для отката к оригиналу, кнопка *Reset* сбрасывает все изменения персонажа разом.

═══════════════════════════════════════════════════════════════════════
# СТРУКТУРА ПРОЕКТА
═══════════════════════════════════════════════════════════════════════

## Дерево файлов

src/
├── api/
│   ├── swapi.ts             `fetchCharacters` с параметрами *page* и *search*, `fetchCharacter` по ID, `getCharacterId` парсит URL
│   ├── localStorage.ts      `saveCharacterEdits` мержит с существующими правками, `getCharacterEdits` возвращает null если нет изменений
│   │                         автоудаление записи если все поля пустые, ключ хранилища `star-wars-character-edits`
│   └── types.ts             интерфейс `Character` с полями SWAPI, `CharacterEdits` для частичных изменений, `CharactersResponse` для пагинации
│
├── components/
│   ├── ui/                  shadcn компоненты: `Card`, `Button`, `Input`, `Badge`, `Skeleton`, `Select`, `Alert`, `Separator`, `Tooltip`, `HoverCard`
│   │
│   ├── CharacterCard.tsx    flip-анимация при hover: фронт с изображением *3:4* и именем, бэк с деталями через `framer-motion`
│   │                         badge *Edited* если `hasCharacterEdits(id)` возвращает true, `Link` на `/character/:id`
│   │
│   ├── CharacterCardSkeleton.tsx  плейсхолдер с `Skeleton` для изображения *3:4* и текстовых блоков, показывается до загрузки данных
│   │
│   ├── SearchBar.tsx        `Input` с иконкой `Search` из `lucide-react`, `type="search"` для нативного крестика очистки
│   │
│   └── Pagination.tsx       кнопки Previous/Next с `ChevronLeft`/`ChevronRight`, генерация номеров страниц через `generatePageNumbers`
│                             показывает первую, текущую, последнюю + ellipsis между ними, текст *Showing page X of Y (Z total characters)*
│
├── hooks/
│   ├── useCharacters.ts     `useState` для data/loading/error, `useEffect` запускается при смене *page* или *search*, cleanup через AbortController
│   │
│   ├── useCharacter.ts      загружает персонажа по ID, мержит с `getCharacterEdits(id)` через spread: `{ ...apiData, ...localEdits }`
│   │
│   ├── useCharacterEdit.ts  управляет режимами *view/edit*, `handleSave` вызывает `saveCharacterEdits`, `handleReset` вызывает `clearCharacterEdits`
│   │                         `handleFieldUndo` сбрасывает одно поле через сохранение объекта без этого ключа
│   │
│   ├── useCharacterImage.ts `fetch` изображения из `https://akabab.github.io/starwars-api/id/${id}.jpg`, возвращает `imageUrl` или null если 404
│   │
│   ├── useResourceName.ts   загружает имя ресурса (planet, film, vehicle) по URL через `fetch`, кеширует результат в `useState`
│   │
│   └── useDebounce.ts       задержка значения на *300ms* через `setTimeout`, cleanup отменяет предыдущий timeout при быстром вводе
│
├── lib/
│   ├── formatters.ts        `formatField` заменяет *unknown* → *Not recorded*, добавляет единицы измерения, `extractIdFromUrl` парсит ID из SWAPI URL
│   │                         `formatDate` через `Intl.DateTimeFormat`, `formatArray` возвращает длину массива или *None*
│   │
│   └── utils.ts             `cn` для объединения classnames через `clsx` и `tailwind-merge`, стандартная утилита shadcn
│
├── pages/
│   ├── CharactersPage.tsx   список персонажей на `/`: URL state через `useSearchParams` для *page* и *search*, debounce через `useDebounce`
│   │                         `Skeleton` до загрузки, сетка *grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4*
│   │
│   └── CharacterDetailPage.tsx  страница `/character/:id`: режимы *view* (читай) и *edit* (редактирование инпутов), кнопка *Undo* рядом с измененными полями
│                                 lightbox для изображения через `yet-another-react-lightbox`, списки films/vehicles/starships через `useResourceName`
│
├── App.tsx                  роутинг `BrowserRouter`: `/` → `CharactersPage`, `/character/:id` → `CharacterDetailPage`
├── main.tsx                 точка входа React, рендер `<App />` в `#root`
└── index.css                Tailwind imports + кастомные CSS переменные для темы

tests/                       подробное описание тестирования в `tests/intro.md`: unit (Vitest), integration (RTL + MSW), e2e (Playwright)

═══════════════════════════════════════════════════════════════════════
# ТЕХНОЛОГИИ
═══════════════════════════════════════════════════════════════════════

**Stack:** React 19, Vite 7, TypeScript 5.9, Tailwind CSS 4, React Router 7, Framer Motion, Lucide icons, shadcn/ui, yet-another-react-lightbox.

**SWAPI:** публичный API `swapi.py4e.com/api/people` без авторизации, возвращает *82 персонажа* с пагинацией по *10 штук*, поддерживает `?search=` для фильтрации по имени. Изображения загружаются отдельно из `akabab.github.io/starwars-api/id/{id}.jpg` так как SWAPI не содержит картинок.

**localStorage:** ключ `star-wars-character-edits` хранит объект `{ [characterId]: CharacterEdits }`, при сохранении мержится с существующими правками через `{ ...existing, ...newEdits }`. Автоудаление записи если все поля стали пустыми строками, проверка через `Object.values(edits).every(val => !val)`.

**URL state management:** `useSearchParams` из `react-router-dom` синхронизирует *page* и *search* с URL, при изменении search автосброс на *page=1*. Дебаунс *300ms* перед отправкой запроса через `useDebounce`, cleanup через `AbortController` для отмены предыдущих запросов.

**Framer Motion:** анимация flip карточек через `motion.div` с `animate={{ rotateY: isFlipped ? 180 : 0 }}` и `transformStyle: "preserve-3d"`. Две стороны карточки с `backfaceVisibility: "hidden"`, бэк сторона с `transform: "rotateY(180deg)"` изначально, transition *0.6s* с easing *easeInOut*.

**Вертикальные изображения:** `aspect-ratio: 3/4` для карточек персонажей вместо квадратных, `object-fit: cover` и `object-position: top` чтобы лица не обрезались. В lightbox изображения показываются в оригинальном размере без кропа.

═══════════════════════════════════════════════════════════════════════
# КЛЮЧЕВЫЕ РЕШЕНИЯ
═══════════════════════════════════════════════════════════════════════

**Lightbox для изображений:** клик на фото персонажа открывает полноэкранный просмотр с возможностью увеличения. Можно рассмотреть детали изображения не покидая страницу, закрытие по клику вне картинки или на крестик.

**Умный поиск с пагинацией:** запрос отправляется через *300ms* после остановки ввода (не спамит API при быстром наборе), пагинация автоматически сбрасывается на первую страницу при новом поиске (не застреваешь на пустых страницах), номера страниц показываются компактно через *первая ... текущая ... последняя* вместо всех девяти кнопок подряд.

**Flip-анимация карточек:** при наведении на карточку она плавно переворачивается в 3D, показывая детали персонажа на обратной стороне. Реализовано через `framer-motion` с *0.6s* анимацией и сохранением фиксированной высоты чтобы карточки не прыгали при наведении.

**HoverCard с оригинальным значением:** если отредактировал поле персонажа, при наведении на него появляется всплывающая подсказка с оригинальным значением из API. Не нужно отменять изменения чтобы вспомнить что было изначально — просто наведи мышку.

**Race Conditions Prevention + Memory Leaks:** при быстром переключении страниц запускается несколько запросов одновременно, и более медленный может вернуться позже быстрого — на экране окажутся данные не с той страницы. Решается через `cancelled` флаг в cleanup функции `useEffect`: когда запускается новый запрос или компонент размонтируется, результаты предыдущих запросов игнорируются. Это же предотвращает утечки памяти — все таймеры отменяются через `clearTimeout`, асинхронные операции помечаются как отменённые, не остаётся "зомби" процессов пытающихся обновить state несуществующего компонента.

**Параллельная загрузка через Promise.all:** у персонажа есть массив из 5 фильмов, каждый требует отдельный запрос для получения названия. Вместо последовательной загрузки (*5 секунд* при 1 секунде на запрос) используется `Promise.all` для запуска всех запросов одновременно — итого *1 секунда* независимо от количества. Особенно критично на медленных соединениях и при большом количестве связанных ресурсов (films, vehicles, starships суммарно могут дать 10-15 параллельных запросов).

**Incremental Data Loading (Progressive Rendering):** вместо ожидания полной загрузки всех названий фильмов показываем fallback сразу — *"Film #1, Film #2"*, затем асинхронно заменяем на реальные данные по мере готовности — *"A New Hope, Film #2"* → *"A New Hope, Empire Strikes Back"*. Пользователь видит контент мгновенно, даже если полная загрузка занимает секунды. Работает как progressive JPEG — сначала что-то показываем, потом улучшаем качество, а не держим пустой экран.

**Graceful Error Handling:** каждый асинхронный вызов обёрнут в `try-catch`, ошибки сохраняются в state и показываются через красивый Alert вместо белого экрана смерти. Если не загрузилась картинка — показываем плейсхолдер *"No image available"*, если упал запрос названия фильма — показываем *"Film #1"* вместо краша. Приложение продолжает работать даже когда API падает или пропадает интернет, пользователь может попробовать перезагрузить или продолжить работать с частично загруженными данными.

**localStorage + API merge:** изменения сохраняются в браузере и остаются после перезагрузки страницы, при этом оригинальные данные из API не теряются. При загрузке персонажа локальные правки накладываются поверх данных с сервера, можно редактировать любые поля без регистрации и backend.

**Badge "Edited" на карточках:** если персонаж отредактирован, на его карточке появляется значок *Edited* с иконкой. При просмотре списка сразу видно какие персонажи имеют локальные изменения, не нужно открывать каждого чтобы проверить.

**Undo для отдельных полей:** в режиме редактирования рядом с каждым измененным полем появляется кнопка *Undo*. Можно откатить конкретное поле к оригиналу не сбрасывая остальные изменения — удобно если ошибся только в одном значении из десяти отредактированных.

**URL state для шаринга:** текущая страница и поисковый запрос сохраняются в URL адресе. Можно скопировать ссылку и отправить коллеге — он увидит те же результаты поиска на той же странице, не нужно объяснять словами как повторить фильтры.

**Дополнительно:** skeleton loaders пока грузятся данные (вместо пустой страницы показываются "призрачные" карточки), кнопка *Cancel* для выхода из режима редактирования без сохранения, кнопка *Reset* для сброса всех изменений персонажа разом, автоформатирование пустых значений (*unknown* → *Not recorded*, добавление единиц измерения *172 cm*, *77 kg*).

**Архитектура:** вся бизнес-логика вынесена в custom hooks (`useCharacters`, `useDebounce`, `useCharacterEdit`) вместо раздувания компонентов — это даёт переиспользование хуков в разных местах, простоту тестирования изолированно от UI, возможность легко заменить источник данных (API → mock → localStorage) без изменения компонентов. Чистое разделение слоёв: `/api` содержит только работу с данными, `/hooks` управляют состоянием и эффектами, `/components` только рендерят UI, `/pages` композируют всё вместе. Каждый модуль решает одну задачу (Single Responsibility Principle), компоненты тонкие и декларативные, логика инкапсулирована и тестируема.

**Accessibility:** semantic HTML (`<button>`, `<input type="search">`, `<main>`, `<header>`), `alt` атрибуты на изображениях, keyboard navigation (Enter/Escape для модалок, Tab для фокуса), ARIA labels для интерактивных элементов, focus management в lightbox и формах редактирования.

═══════════════════════════════════════════════════════════════════════
# ТЕСТИРОВАНИЕ
═══════════════════════════════════════════════════════════════════════

**Полная пирамида тестов:** unit тесты для чистых функций (formatters, localStorage, swapi), integration тесты для хуков и компонентов (RTL + MSW), e2e тесты для критичных флоу (Playwright). Детальное описание всех тестов, моков MSW, стратегии тестирования и команды запуска находится в `tests/intro.md`.
